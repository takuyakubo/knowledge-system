---
title: Claude Code 協働戦略ガイド
created_at: 2025-06-14
updated_at: 2025-06-15
---

このドキュメントは、Claude Codeとの効果的な協働方法と、CLAUDE.mdの進化戦略について詳しく説明します。
人間はもちろん、Claude Codeも、このドキュメントに記載されたルールに従って、CLAUDE.mdを更新する必要があります。

## CLAUDE.md保守戦略

### CLAUDE.mdの情報密度の最適化

**高優先度情報（最初の100行以内）**
- 頻繁に使用するコマンド
- 重要なコーディング規約
- プロジェクト固有の制約

**中優先度情報（100-300行）**
- プロジェクト構造の詳細
- 開発環境のセットアップ
- テスト戦略

**低優先度情報（300行以降）**
- 歴史的経緯
- 稀に使用する設定
- 詳細なトラブルシューティング

### 自動更新トリガー

CLAUDE.mdは静的なドキュメントではなく、常にup-to-dateに更新される必要があります。
以下の状況でCLAUDE.mdの更新を検討してください：

#### 1. 頻度ベースのトリガー
- **同じ質問が2回以上発生** → 即座にFAQとして追加
- **同じ修正パターンが3回以上繰り返し** → ベストプラクティスとして標準化
- **新しいエラーパターンを2回以上確認** → トラブルシューティングに追加

#### 2. 変更ベースのトリガー
- **新しい依存関係の追加時**
   ```bash
   # 追加後にCLAUDE.mdに使用方法を記載
   uv add new-package
   ```
- **プロジェクト構造の変更**
   - 新しいディレクトリの追加
   - アーキテクチャの変更
   - 設定ファイルの変更
- **チーム開発慣習の変更**
   - コーディング規約の更新
   - レビュープロセスの変更
   - デプロイ手順の変更

### モジュール化戦略（大規模プロジェクト用）

```
CLAUDE.md                 # メインファイル（コア情報）
├── @docs/development.md  # 開発固有の詳細
├── @docs/deployment.md   # デプロイメント手順
├── @docs/architecture.md # アーキテクチャ決定記録
└── @docs/team-rules.md   # チーム固有のルール
```

## 効果的なフィードバックループ

### Claude Codeからの学習パターン

1. **繰り返し修正される内容の識別**
   - 型ヒントの追加パターン
   - 特定のコーディングスタイルの修正
   - テストパターンの一貫性

2. **プロジェクト固有の知識の蓄積**
   ### 例1: データベース操作のパターン
   ```python
   # 推奨: 必ずトランザクションを使用
   async with db.transaction():
       await user_repo.create(user_data)
       await audit_log.record(action)
   ```

   ### 例2: API設計ルール
   - 必ず `BaseResponse` を継承したレスポンスモデルを使用
   - エラーハンドリングは `@handle_api_errors` デコレータで統一
   - バリデーションエラーは具体的なフィールド名を含める

3. **成功指標とメトリクス**
   - Claude Codeとのやり取りでの再質問回数（目標: 30%減少）
   - 新メンバーのオンボーディング時間（目標: 50%短縮）
   - コードレビューでの指摘事項数（目標: 40%減少）

## アンカーコメントの活用

コード内にClaude Code専用のアンカーコメントを活用：

```python
# AIDEV-NOTE: このクラスは外部APIとの統合専用
# AIDEV-TODO: パフォーマンス最適化が必要（レスポンス時間>500ms）
# AIDEV-QUESTION: この実装でメモリリークの可能性は？
```

### 段階的な実装アプローチ

新機能を実装する際は、以下の順序で進める：

1. **インターフェース設計**
   ```python
   # まず Protocol や ABC でインターフェースを定義
   from abc import ABC, abstractmethod

   class DataProcessor(ABC):
       @abstractmethod
       def process(self, data: Any) -> Any:
           """データを処理する"""
   ```

2. **テストファースト**
   ```python
   # 実装前にテストを書く
   def test_processor_handles_empty_data():
       processor = MyProcessor()
       assert processor.process([]) == []
   ```

3. **段階的な実装**
   - 最小限の実装から始める
   - リファクタリングで改善
   - パフォーマンス最適化は最後

## エラーメッセージの改善原則

### 1. 具体的で実用的

```python
# Bad
raise ValueError("Invalid input")

# Good
raise ValueError(
    f"Expected positive integer for 'count', got {count}. "
    f"Please provide a value greater than 0."
)
```

### 2. コンテキストを提供

```python
try:
    result = process_data(data)
except ProcessingError as e:
    raise ProcessingError(
        f"Failed to process data from {source_file}: {e}"
    ) from e
```

### 3. 解決策を提示

```python
if not config_file.exists():
    raise FileNotFoundError(
        f"Configuration file not found at {config_file}. "
        f"Create one by running: python -m {__package__}.init_config"
    )
```

## コード生成の品質基準

1. **冪等性**: 同じ操作を複数回実行しても結果が同じ
2. **防御的プログラミング**: 入力を信頼せず、常に検証
3. **リソース管理**: コンテキストマネージャーを使用

## 明確な指示のベストプラクティス

- 実装したい機能の具体的な要件を提供
- 期待される入出力の例を含める
- エッジケースを明示的に説明
- 段階的な要求（設計 → インターフェース → テスト → 実装 → 最適化）

### 実践的な更新ワークフローの例

#### シナリオ1: 新機能導入時の更新手順
1. **影響範囲の事前評価**
   - 新機能が既存手順に与える影響を分析
   - 関連するドキュメントを特定
   - 更新が必要な箇所をリストアップ

2. **段階的な情報更新**
   - 基本的な使用方法の追加
   - 既存情報との整合性確認
   - 具体的な使用例とベストプラクティスの記載

3. **検証と調整**
   - 新しい手順が実際に動作することを確認
   - チームメンバーによるレビューと改善提案
   - 必要に応じて追加の説明や注意事項を追加

#### シナリオ2: 繰り返し問題の対処
1. **問題パターンの分析**
   - 同じ問題が発生する根本原因を特定
   - 予防可能な要因と対処が必要な要因を分類

2. **予防的情報の充実**
   - 問題を未然に防ぐためのチェックリスト作成
   - よくあるミスとその回避方法の明記
   - 関連する設定や環境要因の説明

3. **トラブルシューティングの強化**
   - 具体的なエラーメッセージと対処法の対応表
   - 段階的な診断手順の提供
   - 関連するログや設定の確認方法

### 分散メモリ管理の最適化

#### メインメモリ（CLAUDE.md）の役割
- **頻繁に使用する情報**: 日常的なコマンドと基本設定
- **プロジェクト固有の重要ルール**: 他では代替できない情報
- **適切な参照リンク**: 詳細情報への導線

#### 専門ガイド（サブメモリ、`docs/`ディレクトリ）の役割
- **深掘り情報**: 特定技術スタックの詳細設定
- **高度な使用法**: エキスパート向けの情報
- **トラブルシューティング**: 複雑な問題の解決手順

#### 参照関係の健全性維持
- **明確な責任分担**: どのドキュメントがどの情報を管理するか
- **循環参照の回避**: 参照チェーンが無限ループしない設計
- **更新時の連鎖確認**: 一つの更新が他に与える影響の事前チェック

この体系的なアプローチにより、CLAUDE.mdは単なる静的ドキュメントから、プロジェクトと共に進化する「生きた知識ベース」へと発展していきます。
